


-- SEMPRE QUE SE USA UMA FUNÇÃO DE AGREGAÇÃO É NECESSÁRIO AGRUPAR (GROUP BY)

-- "HAVING" É UM FILTRO DA CLAUSULA "GROUP BY", ASSIM COMO O "WHERE" É UM FILTRO DA CLAUSULA "SELECT"


-- UMA FORMA DE SE DETERMINAR O VALOR DA COLUNA AMOUNT DA TABELA ORDER_DATA
SELECT
	 PEDIDO.ORDERDATE
	,PEDIDO.ORDERID
	,PEDIDO.CUSTOMERID
	,SUM(PRODUTO.UNITPRICE * ITEM.QUANTITY)  VLR_TOTAL

FROM ORDER_DATA PEDIDO
INNER JOIN LINEITEM ITEM
	ON ITEM.ORDERID = PEDIDO.ORDERID
INNER JOIN PRODUCT PRODUTO
	ON PRODUTO.PRODUCTID = ITEM.PRODUCTID
--WHERE PEDIDO.ORDERID = 51
GROUP BY PEDIDO.ORDERDATE, PEDIDO.ORDERID, PEDIDO.CUSTOMERID
HAVING SUM(PRODUTO.UNITPRICE * ITEM.QUANTITY) >= 3000



-- MÉDIA DO VALOR DOS PEDIDOS
SELECT
	AVG(PRODUTO.UNITPRICE * ITEM.QUANTITY)  MÉDIA

FROM ORDER_DATA PEDIDO
INNER JOIN LINEITEM ITEM
	ON ITEM.ORDERID = PEDIDO.ORDERID
INNER JOIN PRODUCT PRODUTO
	ON PRODUTO.PRODUCTID = ITEM.PRODUCTID

-- A FUNÇÃO AVG É O EQUIVALENTE A FAZER :
-- SUM(PRODUTO.UNITPRICE * ITEM.QUANTITY) / COUNT(*)
SELECT
	SUM(PRODUTO.UNITPRICE * ITEM.QUANTITY) / COUNT(*)  VLR_TOTAL

FROM ORDER_DATA PEDIDO
INNER JOIN LINEITEM ITEM
	ON ITEM.ORDERID = PEDIDO.ORDERID
INNER JOIN PRODUCT PRODUTO
	ON PRODUTO.PRODUCTID = ITEM.PRODUCTID



-- LIKE
SELECT
[NAME]
FROM CUSTOMER
--WHERE [NAME] LIKE '_i%'
WHERE [NAME] LIKE '%i%'


-- AND, OR
SELECT
[NAME]
FROM CUSTOMER
WHERE ([NAME] LIKE '%i%' AND [NAME] LIKE '_i%') OR [NAME] = ''  


-- IN
SELECT
[NAME]
FROM CUSTOMER
WHERE [NAME] IN ('RICKY','Willium','Mihir')


-- NOT IN
SELECT 
[NAME]
FROM CUSTOMER
WHERE [NAME] NOT IN ('RICKY','Willium','Mihir')


SELECT
[NAME]
FROM CUSTOMER
WHERE CUSTOMERID NOT IN (SELECT DISTINCT CUSTOMERID FROM ORDER_DATA)


-- MAX, MIN
SELECT MIN(ORDERDATE) MENOR_DATA, MAX(ORDERDATE) MAIOR_DATA FROM ORDER_DATA

SELECT ORDERID FROM ORDER_DATA WHERE MIN(ORDERDATE) > '2/3/2005'

SELECT ORDERID, ORDERDATE FROM ORDER_DATA GROUP BY ORDERID, ORDERDATE HAVING MIN(ORDERDATE) > '5/3/2005'


-- CONVERTE UM DADO PARA UM DETERMINADO TIPO DE DADO
SELECT CAST('5/3/2005' AS DATE)
SELECT CONVERT(DATE, '5/3/2005')

-- O TRY_CAST TENTA CONVERTER UM DADO PARA UM DETERMINADO TIPO DE DADO.
-- CASO NÃO SEJA POSSÍVEL, ELE RETORNA "NULO" INVÉS DE GERAR UM ERRO.
SELECT CAST('A' AS DATE)
SELECT TRY_CAST('A' AS DATE)



-- BETWEEN
SELECT DISTINCT
CAST(ORDERDATE AS DATE)
FROM ORDER_DATA
WHERE CAST(ORDERDATE AS DATE) BETWEEN '2005-01-01' AND '2005-04-04'
ORDER BY 1 ASC

